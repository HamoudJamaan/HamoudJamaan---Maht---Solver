package com.hamoudjamaan.mathsolver

import android.Manifest
import android.content.Intent
import android.content.pm.PackageManager
import android.graphics.Bitmap
import android.graphics.Color
import android.net.Uri
import android.os.Bundle
import android.speech.RecognizerIntent
import android.util.Log
import android.view.View
import android.widget.*
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.ContextCompat
import androidx.recyclerview.widget.LinearLayoutManager
import com.github.barteksc.pdfviewer.PDFView
import com.google.mlkit.vision.common.InputImage
import com.google.mlkit.vision.text.Text
import com.google.mlkit.vision.text.TextRecognition
import com.google.mlkit.vision.text.latin.TextRecognizerOptions
import com.hamoudjamaan.mathsolver.databinding.ActivityMainBinding
import io.github.kexanie.library.MathView
import org.json.JSONObject
import java.io.File
import java.text.SimpleDateFormat
import java.util.*
import kotlin.collections.ArrayList

class MainActivity : AppCompatActivity() {
    
    private lateinit var binding: ActivityMainBinding
    private val solutions = mutableListOf<SolutionItem>()
    private val TAG = "HamoudJamaan"
    
    // Permissions launcher
    private val requestPermissionLauncher = registerForActivityResult(
        ActivityResultContracts.RequestMultiplePermissions()
    ) { permissions ->
        val granted = permissions.values.all { it }
        if (!granted) {
            Toast.makeText(this, "Ø¨Ø¹Ø¶ Ø§Ù„Ø£Ø°ÙˆÙ†Ø§Øª Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ø¹Ù…Ù„", Toast.LENGTH_LONG).show()
        }
    }
    
    // Pickers
    private val pickImage = registerForActivityResult(ActivityResultContracts.GetContent()) { uri ->
        uri?.let { processImageWithOCR(it) }
    }
    
    private val pickPdf = registerForActivityResult(ActivityResultContracts.GetContent()) { uri ->
        uri?.let { processPdf(it) }
    }
    
    private val voiceRecognizer = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result ->
        if (result.resultCode == RESULT_OK) {
            val data = result.data
            val results = data?.getStringArrayListExtra(RecognizerIntent.EXTRA_RESULTS)
            results?.get(0)?.let { solveMathProblem(it, "ØµÙˆØª") }
        }
    }
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)
        
        setupUI()
        checkAndRequestPermissions()
        setupRecyclerView()
        setupChart()
    }
    
    private fun setupUI() {
        // Ø§Ù„Ø´Ø¹Ø§Ø± ÙˆØ§Ù„Ø¹Ù†ÙˆØ§Ù†
        binding.tvLogo.text = getString(R.string.logo_text)
        binding.tvTitle.text = getString(R.string.app_description)
        
        // Ø§Ù„Ø£Ø²Ø±Ø§Ø±
        binding.btnCamera.setOnClickListener { 
            if (checkPermission(Manifest.permission.CAMERA)) {
                startCameraCapture()
            } else {
                requestCameraPermission()
            }
        }
        
        binding.btnGallery.setOnClickListener { 
            if (checkPermission(Manifest.permission.READ_EXTERNAL_STORAGE)) {
                pickImage.launch("image/*")
            } else {
                requestStoragePermission()
            }
        }
        
        binding.btnPdf.setOnClickListener { 
            if (checkPermission(Manifest.permission.READ_EXTERNAL_STORAGE)) {
                pickPdf.launch("application/pdf")
            } else {
                requestStoragePermission()
            }
        }
        
        binding.btnVoice.setOnClickListener { 
            if (checkPermission(Manifest.permission.RECORD_AUDIO)) {
                startVoiceRecognition()
            } else {
                requestAudioPermission()
            }
        }
        
        binding.btnContact.setOnClickListener {
            showContactDialog()
        }
        
        binding.btnShareSolution.setOnClickListener {
            shareLastSolution()
        }
        
        binding.btnSaveSolution.setOnClickListener {
            saveLastSolution()
        }
    }
    
    private fun checkAndRequestPermissions() {
        val permissions = arrayOf(
            Manifest.permission.CAMERA,
            Manifest.permission.READ_EXTERNAL_STORAGE,
            Manifest.permission.WRITE_EXTERNAL_STORAGE,
            Manifest.permission.RECORD_AUDIO
        )
        requestPermissionLauncher.launch(permissions)
    }
    
    private fun checkPermission(permission: String): Boolean {
        return ContextCompat.checkSelfPermission(this, permission) == PackageManager.PERMISSION_GRANTED
    }
    
    private fun requestCameraPermission() {
        requestPermissionLauncher.launch(arrayOf(Manifest.permission.CAMERA))
    }
    
    private fun requestStoragePermission() {
        requestPermissionLauncher.launch(arrayOf(
            Manifest.permission.READ_EXTERNAL_STORAGE,
            Manifest.permission.WRITE_EXTERNAL_STORAGE
        ))
    }
    
    private fun requestAudioPermission() {
        requestPermissionLauncher.launch(arrayOf(Manifest.permission.RECORD_AUDIO))
    }
    
    private fun startCameraCapture() {
        // CameraX implementation Ù…Ø¨Ø³Ø·Ø©
        Toast.makeText(this, "Ø§ÙØªØ­ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ù„Ø§Ù„ØªÙ‚Ø§Ø· Ø§Ù„Ø³Ø¤Ø§Ù„ (ØªØ­Øª Ø§Ù„ØªØ·ÙˆÙŠØ± Ø§Ù„ÙƒØ§Ù…Ù„)", Toast.LENGTH_LONG).show()
        // Ù‡Ù†Ø§ ÙŠÙ…ÙƒÙ† Ø¥Ø¶Ø§ÙØ© CameraX ÙƒØ§Ù…Ù„
        // Ù„Ù„Ø§Ø®ØªØ¨Ø§Ø±ØŒ Ø³Ù†Ø³ØªØ®Ø¯Ù… ØµÙˆØ±Ø© ÙˆÙ‡Ù…ÙŠØ©
        val dummyText = "Ø­Ù„ Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø©: 2x + 3 = 7"
        solveMathProblem(dummyText, "ÙƒØ§Ù…ÙŠØ±Ø§")
    }
    
    private fun startVoiceRecognition() {
        val intent = Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH).apply {
            putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL, RecognizerIntent.LANGUAGE_MODEL_FREE_FORM)
            putExtra(RecognizerIntent.EXTRA_LANGUAGE, "ar-SA")
            putExtra(RecognizerIntent.EXTRA_PROMPT, getString(R.string.speak_prompt))
            putExtra(RecognizerIntent.EXTRA_MAX_RESULTS, 1)
        }
        voiceRecognizer.launch(intent)
    }
    
    private fun processImageWithOCR(imageUri: Uri) {
        binding.progressBar.visibility = View.VISIBLE
        val image = InputImage.fromFilePath(this, imageUri)
        val recognizer = TextRecognition.getClient(TextRecognizerOptions.DEFAULT_OPTIONS)
        
        recognizer.process(image)
            .addOnSuccessListener { visionText ->
                binding.progressBar.visibility = View.GONE
                val extractedText = extractMathText(visionText)
                if (extractedText.isNotEmpty()) {
                    solveMathProblem(extractedText, "ØµÙˆØ±Ø©")
                } else {
                    Toast.makeText(this, getString(R.string.error_ocr), Toast.LENGTH_SHORT).show()
                }
            }
            .addOnFailureListener { e ->
                binding.progressBar.visibility = View.GONE
                Log.e(TAG, "OCR Error", e)
                Toast.makeText(this, "${getString(R.string.error_ocr)}: ${e.message}", Toast.LENGTH_LONG).show()
            }
    }
    
    private fun extractMathText(visionText: Text): String {
        val textBlocks = visionText.textBlocks
        val mathText = StringBuilder()
        
        for (block in textBlocks) {
            val blockText = block.text.trim()
            // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø±Ù…ÙˆØ² Ø±ÙŠØ§Ø¶ÙŠØ§ØªÙŠØ©
            if (blockText.containsAnyOf("=", "+", "-", "*", "/", "x", "y", "âˆ«", "âˆš", "Ï€", "sin", "cos", "tan")) {
                mathText.append(blockText).append("\n")
            }
        }
        
        return mathText.toString().trim()
    }
    
    fun String.containsAnyOf(vararg strings: String): Boolean {
        return strings.any { this.contains(it) }
    }
    
    private fun processPdf(pdfUri: Uri) {
        binding.progressBar.visibility = View.VISIBLE
        Toast.makeText(this, getString(R.string.processing), Toast.LENGTH_SHORT).show()
        
        // PDF processing Ù…Ø¨Ø³Ø·Ø©
        binding.progressBar.visibility = View.GONE
        val dummyPdfText = "Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù†Øµ Ù…Ù† PDF: âˆ«(0 to 1) xÂ² dx = 1/3"
        solveMathProblem(dummyPdfText, "PDF")
    }
    
    private fun solveMathProblem(question: String, source: String) {
        binding.progressBar.visibility = View.VISIBLE
        binding.tvCurrentQuestion.text = question
        
        // Ø­Ù„ Ø¨Ø³ÙŠØ· Ù„Ù„Ù…Ø¹Ø§Ø¯Ù„Ø§Øª (ÙŠÙ…ÙƒÙ† ØªÙˆØ³ÙŠØ¹Ù‡Ø§)
        val solution = generateSolution(question)
        val steps = generateSteps(question)
        
        val fullSolution = """
            **Ø§Ù„Ø³Ø¤Ø§Ù„:** $question
            
            **Ø§Ù„Ø­Ù„:** $solution
            
            **Ø§Ù„Ø®Ø·ÙˆØ§Øª Ø§Ù„ØªÙØµÙŠÙ„ÙŠØ©:**
            $steps
            
            **Ø§Ù„Ù…ØµØ¯Ø±:** $source
        """.trimIndent()
        
        val solutionItem = SolutionItem(
            question = question,
            solution = fullSolution,
            source = source,
            timestamp = System.currentTimeMillis()
        )
        
        solutions.add(0, solutionItem) // Ø¥Ø¶Ø§ÙØ© ÙÙŠ Ø§Ù„Ø£Ø¹Ù„Ù‰
        binding.rvSolutions.adapter?.notifyItemInserted(0)
        
        // Ø±Ø³Ù… Ø¨ÙŠØ§Ù†ÙŠ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø¯Ø§Ù„Ø©
        if (question.contains("y=") || question.contains("f(")) {
            drawFunctionGraph(question)
        }
        
        binding.progressBar.visibility = View.GONE
        Toast.makeText(this, "ØªÙ… Ø­Ù„ Ø§Ù„Ø³Ø¤Ø§Ù„ Ø¨Ù†Ø¬Ø§Ø­!", Toast.LENGTH_SHORT).show()
    }
    
    private fun generateSolution(question: String): String {
        return when {
            question.contains("=") -> {
                val parts = question.split("=")
                val left = parts[0].trim()
                val right = parts[1].trim()
                val x = solveLinearEquation(left, right)
                "x = $x"
            }
            question.contains("âˆ«") -> "Ø§Ù„ØªÙƒØ§Ù…Ù„ = ${integrateFunction(question)}"
            question.contains("âˆš") -> "Ø§Ù„Ø¬Ø°Ø± Ø§Ù„ØªØ±Ø¨ÙŠØ¹ÙŠ = ${squareRoot(question)}"
            question.contains("sin") || question.contains("cos") -> {
                "Ø§Ù„Ù‚ÙŠÙ…Ø© = ${trigonometricFunction(question)}"
            }
            else -> "Ø§Ù„Ø­Ù„ Ø§Ù„Ø¹Ø§Ù…: ${simplifyExpression(question)}"
        }
    }
    
    private fun solveLinearEquation(left: String, right: String): String {
        // Ø­Ù„ Ù…Ø¹Ø§Ø¯Ù„Ø© Ø®Ø·ÙŠØ© Ø¨Ø³ÙŠØ·Ø©
        val leftCoeff = extractCoefficient(left, 'x')
        val constant = extractConstant(right)
        val solution = if (leftCoeff != 0.0) (constant / leftCoeff).toString() else "Ù„Ø§ Ø­Ù„"
        return String.format("%.2f", solution.toDoubleOrNull() ?: 0.0)
    }
    
    private fun extractCoefficient(expression: String, variable: Char): Double {
        // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…Ø¹Ø§Ù…Ù„ Ø§Ù„Ù…ØªØºÙŠØ±
        val pattern = Regex("([+-]?\\d*)\\s*$variable")
        val match = pattern.find(expression)
        return match?.groupValues?.get(1)?.toDoubleOrNull() ?: 1.0
    }
    
    private fun extractConstant(expression: String): Double {
        val pattern = Regex("([+-]?\\d+)")
        val match = pattern.find(expression)
        return match?.groupValues?.get(1)?.toDoubleOrNull() ?: 0.0
    }
    
    private fun integrateFunction(integral: String): String {
        // ØªÙƒØ§Ù…Ù„ Ø¨Ø³ÙŠØ·
        return when {
            integral.contains("x") -> "xÂ²/2 + C"
            integral.contains("xÂ²") -> "xÂ³/3 + C"
            else -> "Ø§Ù„ØªÙƒØ§Ù…Ù„ Ø§Ù„Ù…Ø­Ø³ÙˆØ¨"
        }
    }
    
    private fun squareRoot(expression: String): String {
        val number = expression.replace("âˆš", "").trim().toDoubleOrNull() ?: 0.0
        return String.format("%.2f", kotlin.math.sqrt(number))
    }
    
    private fun trigonometricFunction(expression: String): String {
        val angle = extractAngle(expression)
        return when {
            expression.contains("sin") -> String.format("%.2f", kotlin.math.sin(kotlin.math.toRadians(angle)))
            expression.contains("cos") -> String.format("%.2f", kotlin.math.cos(kotlin.math.toRadians(angle)))
            else -> "0.00"
        }
    }
    
    private fun extractAngle(expression: String): Double {
        val pattern = Regex("(\\d+)Â°?")
        val match = pattern.find(expression)
        return match?.groupValues?.get(1)?.toDoubleOrNull() ?: 30.0
    }
    
    private fun simplifyExpression(expression: String): String {
        // ØªØ¨Ø³ÙŠØ· ØªØ¹Ø¨ÙŠØ± Ø¨Ø³ÙŠØ·
        return expression.replace(" ", "").replace("++", "+").replace("--", "+")
    }
    
    private fun generateSteps(question: String): String {
        return when {
            question.contains("=") -> """
            1. Ù†Ù‚Ù„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø¥Ù„Ù‰ Ø¬Ø§Ù†Ø¨ ÙˆØ§Ø­Ø¯
            2. Ù†Ù‚Ù„ Ø§Ù„Ø«ÙˆØ§Ø¨Øª Ø¥Ù„Ù‰ Ø§Ù„Ø¬Ø§Ù†Ø¨ Ø§Ù„Ø¢Ø®Ø±
            3. Ù‚Ø³Ù…Ø© Ø§Ù„Ø·Ø±ÙÙŠÙ† Ø¹Ù„Ù‰ Ù…Ø¹Ø§Ù…Ù„ x
            4. Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù‚ÙŠÙ…Ø© x
            """.trimIndent()
            
            question.contains("âˆ«") -> """
            1. ØªØ­Ø¯ÙŠØ¯ Ø­Ø¯ÙˆØ¯ Ø§Ù„ØªÙƒØ§Ù…Ù„
            2. Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø´ØªÙ‚ Ø§Ù„Ø¹ÙƒØ³ÙŠ Ù„Ù„Ø¯Ø§Ù„Ø©
            3. ØªØ·Ø¨ÙŠÙ‚ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„ØªÙƒØ§Ù…Ù„ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
            4. Ø¥Ø¶Ø§ÙØ© Ø«Ø§Ø¨Øª Ø§Ù„ØªÙƒØ§Ù…Ù„ C
            """.trimIndent()
            
            else -> """
            1. Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ø³Ø¤Ø§Ù„ Ø¨Ø¹Ù†Ø§ÙŠØ©
            2. ØªØ­Ø¯ÙŠØ¯ Ù†ÙˆØ¹ Ø§Ù„Ù…Ø³Ø£Ù„Ø©
            3. ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù‚ÙˆØ§Ù†ÙŠÙ† Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§ØªÙŠØ© Ø§Ù„Ù…Ù†Ø§Ø³Ø¨Ø©
            4. Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù†ØªÙŠØ¬Ø©
            """.trimIndent()
        }
    }
    
    private fun setupRecyclerView() {
        binding.rvSolutions.layoutManager = LinearLayoutManager(this)
        binding.rvSolutions.adapter = SolutionsAdapter(solutions) { position ->
            showSolutionDetails(position)
        }
    }
    
    private fun setupChart() {
        // Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠ
        binding.chartView.description.isEnabled = false
        binding.chartView.setTouchEnabled(true)
        binding.chartView.isDragEnabled = true
        binding.chartView.setScaleEnabled(true)
        binding.chartView.setDrawGridBackground(false)
    }
    
    private fun drawFunctionGraph(function: String) {
        // Ø±Ø³Ù… Ø¯Ø§Ù„Ø© Ø¨Ø³ÙŠØ·Ø© y = xÂ² ÙƒÙ…Ø«Ø§Ù„
        val entries = ArrayList<com.github.mikephil.charting.data.Entry>()
        
        for (i in -10..10) {
            val x = i.toFloat()
            val y = x * x // y = xÂ²
            entries.add(com.github.mikephil.charting.data.Entry(x, y))
        }
        
        val dataSet = com.github.mikephil.charting.data.LineDataSet(entries, "y = xÂ²")
        dataSet.color = Color.BLUE
        dataSet.valueTextColor = Color.BLACK
        
        val lineData = com.github.mikephil.charting.data.LineData(dataSet)
        binding.chartView.data = lineData
        binding.chartView.invalidate()
        binding.chartView.visibility = View.VISIBLE
    }
    
    private fun showSolutionDetails(position: Int) {
        val solution = solutions[position]
        AlertDialog.Builder(this)
            .setTitle("ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø­Ù„")
            .setMessage(solution.solution)
            .setPositiveButton("Ù…Ø´Ø§Ø±ÙƒØ©") { _, _ -> shareSolution(solution) }
            .setNegativeButton("Ø­ÙØ¸ PDF") { _, _ -> saveAsPdf(solution) }
            .setNeutralButton("Ø¥ØºÙ„Ø§Ù‚", null)
            .show()
    }
    
    private fun shareLastSolution() {
        if (solutions.isNotEmpty()) {
            shareSolution(solutions[0])
        } else {
            Toast.makeText(this, "Ù„Ø§ ØªÙˆØ¬Ø¯ Ø­Ù„ÙˆÙ„ Ù„Ù„Ù…Ø´Ø§Ø±ÙƒØ©", Toast.LENGTH_SHORT).show()
        }
    }
    
    private fun shareSolution(solution: SolutionItem) {
        val shareIntent = Intent(Intent.ACTION_SEND).apply {
            type = "text/plain"
            putExtra(Intent.EXTRA_SUBJECT, "Ø­Ù„ Ù…Ø³Ø£Ù„Ø© Ø±ÙŠØ§Ø¶ÙŠØ§Øª - Ø­Ù…ÙˆØ¯ Ø¬Ù…Ø¹Ø§Ù†")
            putExtra(Intent.EXTRA_TEXT, solution.solution)
        }
        startActivity(Intent.createChooser(shareIntent, "Ù…Ø´Ø§Ø±ÙƒØ© Ø§Ù„Ø­Ù„"))
    }
    
    private fun saveLastSolution() {
        if (solutions.isNotEmpty()) {
            saveAsPdf(solutions[0])
        } else {
            Toast.makeText(this, "Ù„Ø§ ØªÙˆØ¬Ø¯ Ø­Ù„ÙˆÙ„ Ù„Ø­ÙØ¸Ù‡Ø§", Toast.LENGTH_SHORT).show()
        }
    }
    
    private fun saveAsPdf(solution: SolutionItem) {
        // Ø­ÙØ¸ ÙƒÙ€PDF Ø¨Ø³ÙŠØ·
        val timestamp = SimpleDateFormat("yyyyMMdd_HHmmss", Locale.getDefault()).format(Date())
        val fileName = "MathSolution_$timestamp.pdf"
        
        Toast.makeText(this, "ØªÙ… Ø­ÙØ¸ Ø§Ù„Ø­Ù„ ÙƒÙ€ $fileName ÙÙŠ Ø§Ù„ØªÙ†Ø²ÙŠÙ„Ø§Øª", Toast.LENGTH_LONG).show()
        
        // Ù‡Ù†Ø§ ÙŠÙ…ÙƒÙ† Ø¥Ø¶Ø§ÙØ© iText Ø£Ùˆ PdfDocument Ù„Ø¥Ù†Ø´Ø§Ø¡ PDF Ø­Ù‚ÙŠÙ‚ÙŠ
    }
    
    private fun showContactDialog() {
        val options = arrayOf(
            "ðŸ“§ Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ: HamoudJamaan@gmail.com",
            "ðŸ“± ÙˆØ§ØªØ³Ø§Ø¨ 1: 00967778870511", 
            "ðŸ“± ÙˆØ§ØªØ³Ø§Ø¨ 2: 00967736419402"
        )
        
        AlertDialog.Builder(this)
            .setTitle("Ø§ØªØµÙ„ Ø¨Ù†Ø§ - Ø­Ù…ÙˆØ¯ Ø¬Ù…Ø¹Ø§Ù†")
            .setItems(options) { _, which ->
                when (which) {
                    0 -> {
                        val intent = Intent(Intent.ACTION_SENDTO).apply {
                            data = Uri.parse("mailto:HamoudJamaan@gmail.com")
                            putExtra(Intent.EXTRA_SUBJECT, "Ø§Ø³ØªÙØ³Ø§Ø± Ø¹Ù† ØªØ·Ø¨ÙŠÙ‚ Ø­Ù…ÙˆØ¯ Ø¬Ù…Ø¹Ø§Ù†")
                        }
                        try {
                            startActivity(intent)
                        } catch (e: Exception) {
                            Toast.makeText(this, "Ø§ÙØªØ­ ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ", Toast.LENGTH_SHORT).show()
                        }
                    }
                    1 -> startActivity(Intent(Intent.ACTION_VIEW, Uri.parse("https://wa.me/00967778870511")))
                    2 -> startActivity(Intent(Intent.ACTION_VIEW, Uri.parse("https://wa.me/00967736419402")))
                }
            }
            .setNegativeButton("Ø¥ØºÙ„Ø§Ù‚", null)
            .show()
    }
    
    override fun onRequestPermissionsResult(
        requestCode: Int,
        permissions: Array<out String>,
        grantResults: IntArray
    ) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults)
        if (requestCode == 1001) {
            val granted = grantResults.all { it == PackageManager.PERMISSION_GRANTED }
            if (!granted) {
                Toast.makeText(this, "Ø§Ù„Ø£Ø°ÙˆÙ†Ø§Øª Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ø¹Ù…Ù„ Ø§Ù„ÙƒØ§Ù…Ù„", Toast.LENGTH_LONG).show()
            }
        }
    }
}

